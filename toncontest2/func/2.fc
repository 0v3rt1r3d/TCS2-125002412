{-

  TASK 2 - Merge hashmaps (dictionaries)
  Write the method that merges two hashmaps into one. When keys of hashmaps
  interesect - values from first hashmap should be used, while discarded
  key/value pairs should be stored into separate hashmap.
  Method should return two hashmaps (merged_dict, discared_dict). If any
  of resulting hashmaps is empty it should be represented by `null` value.
  Hashmap key length is 256 bit. Each hashmap has at most 256 elements.
-}

() recv_internal() {
}

(int, int) dict_range(cell dict, int key_len) {
  (int mink, _, int ok) = dict.idict_get_min?(key_len);
  throw_if(2, ~ ok);

  (int maxk, _, int ok) = dict.idict_get_max?(key_len);
  throw_if(2, ~ ok);

  return (mink, maxk);
}


;; testable
(cell, cell) merge_hashmaps(cell dict1, cell dict2) method_id {
  ;; Constants
  int key_len = 256; ;; TODO: try global and const?

  ;; Outputs
  cell merged = new_dict();
  cell discarded = new_dict();

  (int mink1, int maxk1) = dict1.dict_range(key_len);
  (int mink2, int maxk2) = dict2.dict_range(key_len);

  int mink = min(mink1, mink2);
  int maxk = max(maxk1, maxk2);

  while(mink < maxk) {
    (int k1, slice v1, int ok1) = dict1.idict_get_next?(key_len, mink);
    (int k2, slice v2, int ok2) = dict1.idict_get_next?(key_len, mink);

    if (~ ok1 & ~ ok2) {
      mink = maxk;
    } else {
      if (~ ok2 | k1 < k2) {
        merged~idict_set(key_len, k1, v1);
        mink = k1;
      }
      if (~ ok1 | k1 > k2) {
        merged~idict_set(key_len, k2, v2);
        mink = k2;
      } else { ;; equals
        merged~idict_set(key_len, k1, v1);
        discarded~idict_set(key_len, k2, v2);
        mink = k1;
      }
      mink~dump();
    }
  }

  return (merged, discarded);
}
